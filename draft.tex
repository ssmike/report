\documentclass[pdftex,ptm,12pt,a4paper]{report}

\usepackage[utf8]{inputenc}

\usepackage[russian,english]{babel}
    \addto{\captionsenglish}{\renewcommand{\bibname}{Литература}}
    \addto\captionsenglish{\renewcommand{\figurename}{Рис.}}
    \addto\captionsenglish{\renewcommand{\contentsname}{Содержание}}
    \addto\captionsenglish{\renewcommand{\proofname}{Доказательство}}
\usepackage[T2A]{fontenc}

\makeatletter
\renewcommand*{\ps@plain}{%
  \let\@mkboth\@gobbletwo
  \let\@oddhead\@empty
  \def\@oddfoot{%
    \reset@font
    \hfil
    \thepage
    % \hfil % removed for aligning to the right
  }%
  \let\@evenhead\@empty
  \let\@evenfoot\@oddfoot
}

\usepackage{csquotes}

\usepackage[backend=bibtex]{biblatex}
\bibliography{draft}

\makeatother
\pagestyle{plain}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{cmap}
\usepackage{verbatim}
\usepackage[table,xcdraw]{xcolor}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{graphicx}

%\usepackage{bbm, dsfont}


\makeatletter
\renewcommand{\@chapapp}{Часть}
\makeatother

% Theorem Styles
\newtheorem{theorem}{Теорема}[chapter]
\newtheorem{lemma}[theorem]{Лемма}
\newtheorem{claim}[theorem]{Теорема}
% Definition Styles
\theoremstyle{definition}
\newtheorem{definition}{Определение}[chapter]
\newtheorem{example}{Пример}[chapter]

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

%\usepackage{minted}
%\graphicspath{ {my path} }
%\includegraphics[scale=0.5]{name.png}

%\inputminted{syntax}{code}

% \begin-end{lstlisting}
\catcode`@=11
\def\caseswithdelim#1#2{\left#1\,\vcenter{\normalbaselines\m@th
  \ialign{\strut$##\hfil$&\quad##\hfil\crcr#2\crcr}}\right.}% you might like it without the \strut
\catcode`@=12
%
\def\bcases#1{\caseswithdelim[{#1}}
\def\vcases#1{\caseswithdelim|{#1}}
%

\title{}
\author{М.С. Сурин}
\DeclareMathOperator{\sgn}{sgn}

\begin{document}
\begin{comment}
    \begin{titlepage}
    \newpage

    \begin{center}
    МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РОССИЙСКОЙ ФЕДЕРАЦИИ \\
    \vspace{0.5cm}
    ГОСУДАРСТВЕННОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ \\*
    ВЫСШЕГО ПРОФЕССИОНАЛЬНОГО ОБРАЗОВАНИЯ\\*
    "МОСКОВСКИЙ ФИЗИКО-ТЕХНИЧЕСКИЙ ИНСТИТУТ \\*
    (ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ)" \\*
    \vspace{0.5cm}
    ФАКУЛЬТЕТ ИННОВАЦИЙ И ВЫСОКИХ ТЕХНОЛОГИЙ \\*
    КАФЕДРА АНАЛИЗА ДАННЫХ \\*
    \hrulefill
    \end{center}


    \vspace{8em}

    \begin{center}
    \Large Выпускная квалификационная работа по направлению 01.03.02 <<Прикладные математика и информатика>> \linebreak НА ТЕМУ:
    \end{center}

    \vspace{2.5em}

    \begin{center}
    \textsc{\large{\textbf{TITLE}}}
    \end{center}

    \vspace{6.5em}

    \begin{flushleft}
        Студент \hrulefill Сурин М.С.  \\
    \vspace{1.5em}
        Научный руководитель к.ф-м.н \hrulefill Артемов А.В.\\
    \vspace{1.5em}
    Зам. зав. кафедрой д.ф-м.н, профессор \hrulefill Бунина Е.И.
    \end{flushleft}

    \vspace{\fill}

    \begin{center}
    МОСКВА, 2017
    \end{center}

    \end{titlepage}
\end{comment}

\tableofcontents

\sloppy

\chapter{Введение}
Тестирование распределённых и устойчивых к сбоям баз данных является более сложной задачей чем тестирование монолитных систем
в силу асинхронности сети(\cite{network-reliable}) и возможности аппаратных сбоев.
В частности, при тестировании распределённых баз данных возникает потребность в верификации гарантий, которые даёт тестируемая система.
В данной работе используется метод внесения неисправностей(fault injection) для верификации подсистем Yandex.YT.

\chapter{Обзор литературы}
В данной главе сделан обзор существующих методов
верификации гарантий консистентности распределённых систем.

\section{Формальные спецификации}
Метод формальных спецификаций заключается в построении математической модели системы, формализации требований к ней и последующему
доказательству того, что система удовлетворяет поставленным требованиям. Обычной практикой является использование инструментов, позволяющих получить доказательство в полуавтоматическом режиме(\cite{coq}).
Построение формальных спецификаций полезно при доказательстве корректности модели соответствующей
системы, но  в случае, если модель оказывается достаточно громоздкой, возникают вопросы
соответствия этой модели реальной системе, а также проблемы обновления модели при изменении её функциональности.
Данные ограничения, как отмечают авторы в \cite{models-bounds} сильно повышают стоимость поддержки
и делают данный подход оправданным только для критичных систем.
Впрочем, достаточно большие компании, такие как Amazon, всё-таки могут позволить себе использование формальных моделей
(\cite{amazon-formal-proofs}) наряду с другими методами.

\section{Внесение неисправностей}
Метод внесения неисправностей заключается в искусственном создании неисправностей(аппаратных сбоев), направленном на
тестирование отказоустойчивости системы. Применительно к распределённым системам это такие неисправности, как искусственные разрывы сети или
отказы вычислительных узлов. В отличие от построения спецификаций данный метод не позволяет доказать корректность, но является гораздо менее накладным, а так же не оперирует с производными от конечного продукта(формальной моделью), что расширяет область применения.
Netflix использует этот подход(\cite{netflix-simian-army}) для тестирования своих сервисов.
Многие системы с открытым исходным кодом тестировались при помощи фреймворка jepsen(\cite{jepsen-io}, \cite{jepsen-analyses}), который
упрощает внесение неисправностей(искусственные разрывы сети, и т.д.).
Также существуют примеры применения
гибридных методики, такие как lineage-driven fault injection(\cite{molly}) -- когда вместо того, чтобы тестировать
систему методом чёрного ящика, используется знание протокола, и избирательно теряются сообщения между узлами.
\chapter{Постановка задачи}
В данной работе мы верифицируем подсистемы Yandex.YT, а именно “Кипарис” и “Динамические таблицы”.
Существуют следующие типы нарушений консистентности, которые необходимо обнаружить.
\begin{itemize}
    \item Потеря подтверждённых записей.
    \item Чтение устаревшего состояния.
    \item Чтение данных, появившихся в результате неподтверждённых записей.
\end{itemize}

\section{Кипарис}
“Кипарис” -- распределённое хранилище \guillemotleftключ-значение\guillemotright.
Является CP системой в смысле CAP-теоремы и гарантирует линеаризуемость \cite{linearizable}.

Схема репликации “Кипариса” схожа с идеями, применёнными в Zookeeper \cite{zookeeper} и Raft \cite{raft}.

“Кипарис” запущен на кластере из $2n+1$ машин.
У каждого узла “Кипариса” есть 3 режима работы: лидер, последователь и режим восстановления.

Лидер определяется в процессе голосования, которое устроено следующим образом:
\begin{enumerate}
    \item Узлы рассылают всему кластеру длину записанной истории и свой идентификатор,
    \item Узлы выбирают лидера (узел с наименьшим идентификатором среди имеющих наибольшую длину истории)
        и рассылают остальным идентификатор выбранного лидера.
    \item Узел, за которого проголосовали не менее $n+1$ узлов становится лидером.
\end{enumerate}
Далее каждый узел хранит идентификатор лидера.
Периодически лидер опрашивает последователей, и если не набирается $n$ узлов, для которых верно,
что идентификатор их лидера совпадает с опрашивающим узлом, то начинаются выборы.
Также выборы начинаются, если в течение заранее заданного промежутка времени какой-либо из последователей не был опрошен лидером.

При записи (любом мутирующем запросе) клиент обращается к лидеру, который в свою очередь опрашивает последователей и
реплицирует на них запрос. Лидер отвечает успехом если по крайней мере $n$ последователей подтвердили что их хранимый идентификатор
лидера совпадает с опрашивающим узлом, и они записали изменение на диск.

На запросы чтения лидер отвечает без подтверждения от последователей.
Последователи отвечают на запрос чтения только после того как получено подтверждение от лидера о том, состояние узла не отстаёт от лидера.
Узлы в режиме восстановления на запросы чтения не отвечают. Более того, узлы в режиме восстановления не голосуют при выборах, а только
асинхронно забирают изменения с лидера.

\section{Динамические таблицы}
“Динамические таблицы” -- это также CP-хранилище
    \guillemotleftключ-значение\guillemotright,
    в свою очередь являющееся Snapshot-сериализуемым.

Snapshot-сериализуемость понимается как гарантия того, что каждая транзакция оперирует
с консистентным состоянием хранилища на некоторый момент времени, а также что выполняются условия
последовательной консистентности.
\chapter{Предложенный алгоритм}
В данной работе мы пользуемся фреймворком jepsen(\cite{jepsen-io}).
Общая схема процедуры верификации такова:
В несколько потоков делаются серии запросов к базе, развёрнутой на кластере размера 3-5.
После этого собирается история ответов, которая проверяется на соответствие заявленным гарантиям следующим образом.
Ищется произвольное “правильное” упорядочение запросов. Для проверки линеаризуемости
 используется библиотека knossos(\cite{knossos}).
\section{jepsen}
Jepsen представляет собой библиотеку для написания тестов и состоит из следующих частей:
\begin{itemize}
    \item \textbf{core} -- основной модуль, управляющий установкой и настройкой тестируемой базы,
        запуском потоков, инициирующих запросы к базе. Запросы, а также моделируемые неисправности
        генерируются при помощи данного на вход  генератора и инициируются данным модулем.
        Также передаёт полученную историю модулю \textbf{checker}, и генерирует отчёт.
    \item \textbf{gen} -- модуль, предназначенный для генерации запросов, неисправностей и т.п..
        Представляет из себя набор элементарных генераторов и операторы для их комбинирования.
    \item \textbf{nemesis} -- модуль для внедрения неисправностей, предназначен для запуска
        отдельного рабочего потока, который создаёт искусственные разрывы сети между узлами,
        имитирует сбои отдельных узлов, манипулирует со временем на узлах и т.п..
    \item \textbf{model} -- Предоставляет модель состояния базы, предназначен для проверки правильности результатов запросов.
    \item \textbf{checker} -- Модуль для интеграции пользовательских анализаторов истории с jepsen.
\end{itemize}
\section{knossos}
Данная библиотека помогает найти возможное упорядочение запросов, удовлетворяющее выбранной модели, или убедиться в его отсутствии.
Поиск реализован с помощью перебора с отсечениями. Здесь и далее называем состоянием состояние базы и набор не применённых операций.
Храня состояния в очереди с приоритетами, будем в $n$ потоков
доставать те из них, для которых ожидаемое количество продолжений истории наименьшее, и делать попытку продолжить
ещё на один шаг. Для ускорения общая очередь разбивается на несколько очередей, привязанных к потокам.
Кроме того, используется мемоизация -- если состояние уже было исследовано, то второй раз его исследовать не имеет смысла.

\chapter{Проведённые эксперименты}
\section{Кипарис}
Было исследовано поведение системы при следующих условиях.
\begin{itemize}
    \item Использовалась модель атомарного регистра, со следующими доступными типами операций:
        \begin{itemize}
            \item \textbf{read} -- Чтение значения регистра, возможны исходы:
                \begin{itemize}
                    \item \textbf{ok} -- Удалось прочитать значение регистра.
                    \item \textbf{fail} -- Не удалось прочитать значение.
                \end{itemize}
            \item \textbf{write} -- Запись в регистр, возможны исходы:
                \begin{itemize}
                    \item \textbf{ok} -- Удалось записать значение.
                    \item \textbf{fail} --  Хранилище отклонило операцию.
                    \item \textbf{unknown} -- Возможно удалось записать значение
                        (хранилище не отклонило и не подтвердило операцию).
                \end{itemize}
        \end{itemize}
        Соответственно, все операции с хранилищем производились по одному и тому же ключу.
    \item Запросы осуществлялись в 8 потоков, чтение с последователей разрешено.
    \item Для обнаружения ошибок в сетевую конфигурацию вносились сбои следующего вида:
        кластер разбивался на две примерно равные части, также было исследовано поведение при разбиении
            на две равные части с одним узлом “перемычкой”, который видит остальные.
\end{itemize}
В исходной постановке считалось что исход любой неудавшейся записи -- \textbf{fail}.
После ряда экспериментов, были обнаружены аномалии вида "чтение неподтверждённых записей".
После анализа исходного кода, было обнаружено, что запросы записи нельзя однозначно считать отклонёнными системой.
В скорректированной постановке, ошибок линеаризации на данный момент обнаружено не было.

\section{Динамические таблицы}
Пока не тестировались.

\printbibliography[title=Список литературы]
\end{document}
